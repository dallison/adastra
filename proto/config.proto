// Copyright 2024 David Allison
// All Rights Reserved
// See LICENSE file for licensing information.

syntax = "proto3";

package adastra.stagezero.config;

import "proto/stream.proto";
import "proto/cgroup.proto";
import "proto/parameters.proto";

message Compute {
  string name = 1;
  bytes ip_addr = 2; // Host byte order.
  int32 port = 3;    // Host byte order.
  bool disabled = 4;
  repeated Cgroup cgroups = 5;
}

message Variable {
  string name = 1;   // Varible name
  string value = 2;  // Expression for value (use $ for var names)
  bool exported = 3; // Export to environment.
  bool disabled = 4;
}

message Namespace {
  // These should be combined into the 'type' by ORing them together (except for NS_ANY
  // of course).
  enum Type {
    NS_ANY = 0;
    NS_NEWCGROUP = 1;
    NS_NEWIPC = 2;
    NS_NEWNET = 4;
    NS_NEWPID = 8;
    NS_NEWUSER = 16;
    NS_NEWUTS = 32;
  }
  Type type = 1;
  // Some Linux manuals say that a pidfd can be used to clone the namespaces
  // from another process.  I'm not sure about how widespread the support for this
  // is, so it's not supported for now.
}

// This is used to set the kernel scheduler policy and priority for a process.
// See sched_setscheduler(2) for more information.
message KernelSchedulerPolicy {
  enum Policy {
    KERN_SCHED_DEFAULT = 0;
    KERN_SCHED_BATCH = 1;
    KERN_SCHED_IDLE = 2;
    KERN_SCHED_FIFO = 3;
    KERN_SCHED_RR = 4;
  }
  Policy policy = 1;
  int32 priority = 2;
  bool reset_on_fork = 3;
}

// This encapsulates both the kernel scheduler policy and the CPU affinity for a process.
// It is passed to the process (encoded in protobuf wireformat) as a runtime parameter
// (not a command line argument).
message ProcessKernelPolicyAndCpuAffinity {
  KernelSchedulerPolicy policy = 1;
  repeated int32 cpus = 2;
}

message CapabilitySet {
  repeated string capabilities = 3;
}

message ProcessOptions {
  string name = 1;
  string description = 2;

  repeated config.Variable vars = 3; // Local variables and environment.
  repeated string args = 4;          // Use $var in expressions.

  // Timeouts for shutdown.  The sigint timeout is the number of
  // seconds beteen sending SIGINT and SIGTERM.  -1 means no
  // SIGINT is sent.  Likewise, sigterm timeout is the number of
  // seconds between SIGTERM and SIGKILL.  A value of 0 means
  // use reasonable defaults.
  //
  // If 'telemetry' is true, the telemetry_shutdown_timeout_secs
  // is used to the timeout after sending a shutdown command and
  // before escalating to signals.
  int32 telemetry_shutdown_timeout_secs = 20;
  int32 sigint_shutdown_timeout_secs = 5;
  int32 sigterm_shutdown_timeout_secs = 6;

  bool notify = 7; // Notify of startup via pipe.

  // If the process will notify us, we wait this long for it
  // to do so.
  int32 startup_timeout_secs = 8;

  // User and group for owner of the process.
  string user = 9;
  string group = 10;

  // Interactive only makes sense for static processes.
  bool interactive = 11;

  // Interactive terminal parameters.
  adastra.stagezero.proto.Terminal interactive_terminal = 12;

  // A critical process is one that is needed for the system to work
  // at all.  They are not subject to restart or abort processing.  If
  // they crash, the whole system is brought down.
  bool critical = 13;

  // A oneshot process is expected to run once and exit.  If it exits with a
  // non-zero status or receives a signal it is considered to be a process
  // failure.
  bool oneshot = 14;

  // Cgroup name (if supported by OS).  Must be present on the compute instance.
  string cgroup = 15;

  bool detached = 16; // Process is detached from client.

  // Namespaces to assign to (only on Linux).
  optional Namespace ns = 17;

  // Local parameters for the process.
  repeated adastra.proto.parameters.Parameter parameters = 18;

  // The telemetry API allows the process to accept commands and send
  // telemetry data through a pipe connected to StageZero.
  bool telemetry = 19;   // Use telemetry API.

  // These options are only support on Linux.
  repeated int32 cpus = 21;                            // CPUs to use.
  KernelSchedulerPolicy kernel_scheduler_policy = 22;  // Scheduler to use.

  CapabilitySet capabilities = 23;                     // Capabilities ()
}

message StaticProcess { string executable = 1; }

message VirtualProcess {
  string zygote = 1;    // Zygote to use.
  string dso = 2;       // Dynamic shared object to load (empty for none)
  string main_func = 3; // Main function to call.
}
